---
title: "HTTP/S 协议"
subtitle: ""
date: 2022-09-29T15:15:41+08:00
lastmod: 2022-09-29T15:15:41+08:00
draft: false
author: "lqgl"
description: ""
resources:
- name: "featured-image"
  src: "http.png"

tags: ["NetWork"]
categories: ["DevOps"]

lightgallery: true

toc:
 auto: false
---

## HTTP 是什么？
HTTP 是一种网络协议，而且是无状态的超文本协议，基于 Tcp/Ip 协议的应用层协议。

## HTTP get 和 post 的区别
1. get 是从服务器上获取数据，post 是向服务器传送数据。

2. get 传送的数据量较小，不能大于 2KB。post 传送的数据量较大，一般被默认为不受限制。

3. get 安全性非常低，post 安全性较高。但是执行效率却比 Post 方法好。 
   1. 安全性:get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址。用户看不到这个过程。
   
   2. 效率:get 产生一个 TCP 数据包；post 产生两个 TCP 数据包。对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。

## 报文
### 请求报文
HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。
规范把 HTTP 请求分为三个部分：
1. 状态行

2. 请求头

3. 消息主体

### 响应报文
HTTP 响应与 HTTP 请求相似，HTTP 响应也由 3 个部分构成，分别是：

1. 状态行

2. 响应头 (Response Header)

3. 响应正文

## HTTP 响应状态码
<img src="http-code.png" width="1460px">

### 1XX: 通知
1XX 系列响应代码仅在与 HTTP 服务器沟通时使用。

### 2XX: 成功
2XX 系列响应代码表明操作成功了。

### 3XX: 重定向
3XX 系列响应代码表明：客户端需要做些额外工作才能得到所需要的资源。它们通常用于 GET 请求。他们通常告诉客户端需要向另一个 URI 发送 GET 请求，才能得到所需的表示。那个 URI 就包含在 Location 响应报头里。

### 4XX: 客户端错误
这些响应代码表明客户端出现错误。不是认证信息有问题，就是表示格式或 HTTP 库本身有问题。客户端需要自行改正。

### 5XX: 服务端错误
这些响应代码表明服务器端出现错误。一般来说，这些代码意味着服务器处于不能执行客户端请求的状态，此时客户端应稍后重试。有时，服务器能够估计客户端应在多久之后重试。并把该信息放在 Retry-After 响应报头里。

## URI 和 URL 的区别
1. 统一资源定位符 (uniform resource locator URL)

2. 统一资源标识符 (uniform resource identifier URI)

可以这样理解 URI 表示的是一个抽象的地址，URL 表示的是一个详细的地址。 抽象的地址：湖南省长沙市（这是一个抽象的地址，相当于 URI）
详细的地址：湖南省长沙市雨花区香樟路 22 号（这是一个详细的地址，相当于 URL） 为什么 URL 是 URI 的子集，雨花区的香樟路 22 号（URL）属于湖南省长沙市（URI），
那么放到 web 上 www.csdn.net 是一个 URI（它只说明了服务器的地址，没有具体到文件是什么类型）
那么 www.csdn.net/image/logo.… 这样一来 URL 和 URI 的区别就很清晰了

## Keep-Alive 持久连接
HTTP 协议采用 “请求 - 应答” 模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求 / 应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP 协议为无连接的协议）；

当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。

1. HTTP Keep-Alive 简单说就是保持当前的 TCP 连接，避免了重新建立连接。

2. HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个 TCP 通道可以保持 5 秒，max=100，表示这个长连接最多接收 100 次请求就断开。

## 从输入 URL 到页面加载完成的过程
1. 首先做 DNS 解析，通过域名获得 IP 地址。

2. 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。

3. TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据。

4. 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件。

5. 首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。

6. 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

7. 文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。

8. 初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件。

9. CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西。

10. 在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。

11. 四次挥手断开连接。

## 简单的讲一次完整的 http 连接就是从 url 输入到页面加载的全过程
```markdown
1. DNS域名解析: 浏览器将URL解析出相对应的IP地址和端口号。
     1. 从本地浏览器的DNS缓存中查找
     2. 在系统DNS缓存中查找
     3. 从路由器DNS缓存中查找
     4. 网络运营商DNS缓存中查找
     5. 递归搜索
2. TCP三次握手建立连接。
3. TLS握手，加密传输。
4. 发送HTTP请求，服务器响应请求返回数据文件。
5. 浏览器解析文件，渲染生成页面。
6. 四次挥手断开连接。
```

## Cookie 和 Session
### Cookie
Cookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie。客户端会把 Cookie 保存起来。

当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。

如果没有设置 Cookie 失效日期，它们仅保存到关闭浏览器程序为止.

Cookie 存储的数据量很受限制，大多数浏览器支持最大容量为 4K

Cookie 类型

1. 普通 cookie： 服务端和 js 都可以创建，都可以访问。

2. HttpOnly cookie: 只能由服务端创建，JS 无法读取。

3. 安全的 cookie（https）： 服务端和 JS 都可以创建，JS 仅在 HTTPS 下访问。

### Session
Session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。

### 区别
1. session 在服务器端，cookie 在客户端（浏览器）
2. session 默认被存在在服务器的一个文件里（不是内存）
3. session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）
4. session 可以放在 文件、数据库、或内存中都可以。
5. 用户验证这种场合一般会用 session

--- 

# TLS 协议
## TLS 安全传输层
很多应用层协议都存在安全问题。如 http 协议，在传输过程中使用明文信息，传输报文一旦被截获便会泄漏内容；传输过程中报文如果被篡改，无法轻易发现；
为了解决这个问题，就在应用层和传输层之间加入了 SSL/TLS 协议。

## 什么是 TLS
TLS（Transport Layer Security, 安全传输层）。TLS 是建立在传输层 TCP 协议之上的协议，服务于应用层。前身是 SSL（Secure Socket Layer, 安全套接字层）, 它实现了将应用层报文加密后再交由 TCP 进行传输的可能。

## TLS 的作用
1. 保密。保密通过加密 encryption 实现，所有信息都加密传输，第三方无法嗅探。

2. 完整性。通过 MAC 校验机制，一旦被篡改，通信双方会立刻发现。

3. 认证。双方认证，双方都可以配备证书，防止身份被冒充。

## TLS 实现
TLS 协议分为两部分

1. 通信协议: 通过使用客户端和服务端协商后的密钥进行数据加密传输。

2. 握手协议: 客户端和服务端进行协商，确定一组用于数据传输加密的密钥串。