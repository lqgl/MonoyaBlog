<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=theme-color content="#fcfcfc"><meta name=msapplication-TileColor content="#fcfcfc"><meta itemprop=name content="Slice"><meta itemprop=description content="英文原文:Go Slices: usage and internals 介绍 Go 的切片类型为处理类型化数据的序列提供了一种方便而有效的方法。切片类似于其他语言中的数组，但有一些不寻常的特性。本"><meta itemprop=datePublished content="2022-09-16T09:38:33+08:00"><meta itemprop=dateModified content="2022-09-16T09:38:33+08:00"><meta itemprop=wordCount content="2754"><meta itemprop=keywords content><meta property="og:title" content="Slice"><meta property="og:description" content="英文原文:Go Slices: usage and internals 介绍 Go 的切片类型为处理类型化数据的序列提供了一种方便而有效的方法。切片类似于其他语言中的数组，但有一些不寻常的特性。本"><meta property="og:type" content="article"><meta property="og:url" content="https://lqgl.cool/article/slice-intro/"><meta property="article:section" content="article"><meta property="article:published_time" content="2022-09-16T09:38:33+08:00"><meta property="article:modified_time" content="2022-09-16T09:38:33+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Slice"><meta name=twitter:description content="英文原文:Go Slices: usage and internals 介绍 Go 的切片类型为处理类型化数据的序列提供了一种方便而有效的方法。切片类似于其他语言中的数组，但有一些不寻常的特性。本"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Slice</title><link rel=stylesheet href=https://lqgl.cool/css/style.min.67017a7027c7c05e8e18eb14b38cc24eb9d8c65ce69d53db9e9432c2d580749d.css integrity="sha256-ZwF6cCfHwF6OGOsUs4zCTrnYxlzmnVPbnpQywtWAdJ0=" crossorigin=anonymous></head><body id=page><header id=site-header class="animated slideInUp"><div class="hdr-wrapper section-inner"><div class=hdr-left><div class=site-branding><a href=https://lqgl.cool>Lqgl's Blog</a></div><nav class="site-nav hide-in-mobile"><a href=https://lqgl.cool/article/>Article</a>
<a href=https://lqgl.cool/life/>Life</a>
<a href=https://lqgl.cool/tech/>Tech</a>
<a href=https://lqgl.cool/about-me/>About</a>
<a href=https://lqgl.cool/about-friends/>Friend Links</a></nav></div><div class="hdr-right hdr-icons"><span class="hdr-social hide-in-mobile"><a href=https://twitter.com/ target=_blank rel="noopener me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://instagram.com/ target=_blank rel="noopener me" title=Instagram><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/></svg></a><a href=https://github.com/lqgl target=_blank rel="noopener me" title=Github><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></span><button id=menu-btn class=hdr-btn title=Menu><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div></div></header><div id=mobile-menu class="animated fast"><ul><li><a href=https://lqgl.cool/article/>Article</a></li><li><a href=https://lqgl.cool/life/>Life</a></li><li><a href=https://lqgl.cool/tech/>Tech</a></li><li><a href=https://lqgl.cool/about-me/>About</a></li><li><a href=https://lqgl.cool/about-friends/>Friend Links</a></li></ul></div><main class="site-main section-inner thin animated fadeIn faster"><h1>Slice</h1><div class=content><p>英文原文:<a href=https://go.dev/blog/slices-intro>Go Slices: usage and internals</a></p><h2 id=介绍>介绍<a href=#介绍 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>Go 的切片类型为处理类型化数据的序列提供了一种方便而有效的方法。切片类似于其他语言中的数组，但有一些不寻常的特性。本文将探讨什么是切片以及如何使用切片。</p><h2 id=数组arrays>数组(Arrays)<a href=#数组arrays class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>切片类型是建立在Go的数组类型之上的一个抽象，因此要理解切片，我们必须先理解数组。</p><p>一个数组类型定义指定了一个长度和一个元素类型。例如，[4]int类型表示一个包含四个整数的数组。一个数组的大小是固定的；它的长度是其类型的一部分（[4]int和[5]int是不同的，不兼容的类型）。数组可以用常规方式进行索引，所以表达式s[n]可以访问第n个元素，从0开始。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=p>[</span><span class=mi>4</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nx>i</span> <span class=o>:=</span> <span class=nx>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c1>// i == 1
</span></span></span></code></pre></div><p>数组不需要显式初始化，数组的零值是一个随时可以使用的数组，其元素本身已经归零:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// a[2] == 0, the zero value of the int type
</span></span></span></code></pre></div><p>[4]int的内存表示只是四个按顺序排列的整数值。
<img src=https://go.dev/blog/slices-intro/slice-array.png alt></p><p>Go 的数组是数值。一个数组变量表示整个数组；它不是指向第一个数组元素的指针（在C语言中是这样的）。这意味着当你分配或传递一个数组的值时，你将复制其内容。(为了避免复制，你可以传递一个指向数组的指针，但那是一个指向数组的指针，而不是一个数组。) 考虑数组的一种方法是作为一种结构，但具有索引而不是命名字段：一个固定大小的复合值.</p><p>数组字面值可以这样指定：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;Penn&#34;</span><span class=p>,</span> <span class=s>&#34;Teller&#34;</span><span class=p>}</span>
</span></span></code></pre></div><p>或者，您可以让编译器为您计算数组元素:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=p>[</span><span class=o>...</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;Penn&#34;</span><span class=p>,</span> <span class=s>&#34;Teller&#34;</span><span class=p>}</span>
</span></span></code></pre></div><p>在这两种情况下，b的类型都是[2]string</p><h2 id=切片slices>切片(Slices)<a href=#切片slices class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>数组有自己的位置，但它们有点不灵活，所以在Go代码中不太常见。然而，切片随处可见。它们以数组为基础，提供强大的力量和便利。</p><p>切片的类型规范是[]T，其中T是切片元素的类型。与数组类型不同，切片类型没有指定的长度。</p><p>slice 字面量的声明就像数组字面量一样，只是省略了元素计数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>letters</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=s>&#34;b&#34;</span><span class=p>,</span> <span class=s>&#34;c&#34;</span><span class=p>,</span> <span class=s>&#34;d&#34;</span><span class=p>}</span>
</span></span></code></pre></div><p>切片可以用内置的make函数创建，它的签名是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>T</span><span class=p>,</span> <span class=nx>len</span><span class=p>,</span> <span class=nx>cap</span><span class=p>)</span> <span class=p>[]</span><span class=nx>T</span>
</span></span></code></pre></div><p>T 代表要创建切片的元素类型。make函数接收元素类型，长度和可选容量。调用时，make 将分配一个数组并返回指向该数组的切片。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=nx>s</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// s == []byte{0, 0, 0, 0, 0}
</span></span></span></code></pre></div><p>当省略容量参数时，默认为指定的长度。这是相同代码的更简洁版本：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span></code></pre></div><p>可以使用内置的len和cap函数检查切片的长度和容量</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>==</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=nb>cap</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>==</span> <span class=mi>5</span>
</span></span></code></pre></div><p>接下来的两个部分讨论长度和容量之间的关系。</p><p>切片的零值为nil。len和cap函数对于nil切片都将返回0。</p><p>切片也可以通过“切片”现有的切片或数组来形成。切片是通过指定一个半开的区间和两个用冒号分隔的索引来完成的。例如，表达式b[1:4]创建了一个包含b的元素1到3的切片(结果切片的索引将是0到2)。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=sc>&#39;g&#39;</span><span class=p>,</span> <span class=sc>&#39;o&#39;</span><span class=p>,</span> <span class=sc>&#39;l&#39;</span><span class=p>,</span> <span class=sc>&#39;a&#39;</span><span class=p>,</span> <span class=sc>&#39;n&#39;</span><span class=p>,</span> <span class=sc>&#39;g&#39;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// b[1:4] == []byte{&#39;o&#39;, &#39;l&#39;, &#39;a&#39;}, sharing the same storage as b
</span></span></span></code></pre></div><p>切片表达式的开始和结束索引是可选的;它们的默认值分别为0和slice的长度:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// b[:2] == []byte{&#39;g&#39;, &#39;o&#39;}
</span></span></span><span class=line><span class=cl><span class=c1>// b[2:] == []byte{&#39;l&#39;, &#39;a&#39;, &#39;n&#39;, &#39;g&#39;}
</span></span></span><span class=line><span class=cl><span class=c1>// b[:] == b
</span></span></span></code></pre></div><p>这也是在给定数组的情况下创建切片的语法:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>x</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;Лайка&#34;</span><span class=p>,</span> <span class=s>&#34;Белка&#34;</span><span class=p>,</span> <span class=s>&#34;Стрелка&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=nx>x</span><span class=p>[:]</span> <span class=c1>// a slice referencing the storage of x
</span></span></span></code></pre></div><h2 id=切片内部slice-internals>切片内部(Slice internals)<a href=#切片内部slice-internals class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>一个切片是一个数组段的描述符。它由指向数组的指针、段的长度和它的容量(段的最大长度)组成。
<img src=https://go.dev/blog/slices-intro/slice-struct.png alt></p><p>之前由 make([]byte, 5) 创建的变量s的结构是这样的:
<img src=https://go.dev/blog/slices-intro/slice-1.png alt></p><p>长度是切片引用的元素的数量。容量是底层数组中的元素数量(从切片指针引用的元素开始)。在接下来的几个示例中，我们将清楚地说明长度和容量之间的区别。</p><p>当我们对s切片时，观察切片数据结构的变化及其与基础数组的关系：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>2</span><span class=p>:</span><span class=mi>4</span><span class=p>]</span>
</span></span></code></pre></div><p><img src=https://go.dev/blog/slices-intro/slice-2.png alt></p><p>切片操作不会复制原始切片的数据。它创建一个指向原始数组的新切片值。这使得切片操作与操作数组下标一样高效。因此，修改新切片的元素(而不是切片本身)会修改原始切片的元素:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>d</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=sc>&#39;r&#39;</span><span class=p>,</span> <span class=sc>&#39;o&#39;</span><span class=p>,</span> <span class=sc>&#39;a&#39;</span><span class=p>,</span> <span class=sc>&#39;d&#39;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>e</span> <span class=o>:=</span> <span class=nx>d</span><span class=p>[</span><span class=mi>2</span><span class=p>:]</span>
</span></span><span class=line><span class=cl><span class=c1>// e == []byte{&#39;a&#39;, &#39;d&#39;}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>e</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=sc>&#39;m&#39;</span>
</span></span><span class=line><span class=cl><span class=c1>// e == []byte{&#39;a&#39;, &#39;m&#39;}
</span></span></span><span class=line><span class=cl><span class=c1>// d == []byte{&#39;r&#39;, &#39;o&#39;, &#39;a&#39;, &#39;m&#39;}
</span></span></span></code></pre></div><p>之前我们将s切成比其容量更短的长度。我们可以通过再次切片使s增长到它的容量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[:</span><span class=nb>cap</span><span class=p>(</span><span class=nx>s</span><span class=p>)]</span>
</span></span></code></pre></div><p><img src=https://go.dev/blog/slices-intro/slice-3.png alt></p><p>一个切片不能超过它的容量。尝试这样做将导致运行时恐慌，就像在切片或数组边界外进行索引一样。同样，不能将切片重新切到0以下以访问数组中较早的元素。</p><h2 id=growing-slices-the-copy-and-append-functions>Growing slices (the copy and append functions)<a href=#growing-slices-the-copy-and-append-functions class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>要增长一个切片的容量，必须创建一个新的、更大的切片，并将原始切片的内容复制到其中。这种技术就是来自其他语言的动态数组实现在幕后工作的方式。下面的例子通过创建一个新的切片t，将s的内容复制到t中，然后将切片值t赋给s，从而使s的容量翻倍:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>t</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>),</span> <span class=p>(</span><span class=nb>cap</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>)</span> <span class=c1>// +1 in case cap(s) == 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>s</span> <span class=p>=</span> <span class=nx>t</span>
</span></span></code></pre></div><p>内置的copy函数简化了这个常见操作的循环部分。顾名思义，copy将数据从源片复制到目标片。它返回复制的元素数量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nb>copy</span><span class=p>(</span><span class=nx>dst</span><span class=p>,</span> <span class=nx>src</span> <span class=p>[]</span><span class=nx>T</span><span class=p>)</span> <span class=kt>int</span>
</span></span></code></pre></div><p>copy 函数支持在不同长度的切片之间进行复制(它只复制较少数量的元素)。此外，copy函数可以处理共享相同底层数组的源片和目标片，正确处理重叠的切片。</p><p>使用copy，我们可以简化上面的代码片段:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>t</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>),</span> <span class=p>(</span><span class=nb>cap</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>copy</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>s</span> <span class=p>=</span> <span class=nx>t</span>
</span></span></code></pre></div><p>一种常见的操作是将数据追加到一个切片的末尾。这个函数将字节元素追加到字节的切片中，必要时增加切片，并返回更新后的切片值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>AppendByte</span><span class=p>(</span><span class=nx>slice</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>data</span> <span class=o>...</span><span class=kt>byte</span><span class=p>)</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>slice</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nx>m</span> <span class=o>+</span> <span class=nb>len</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=p>&gt;</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>slice</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// if necessary, reallocate
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// allocate double what&#39;s needed, for future growth.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>newSlice</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=p>(</span><span class=nx>n</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>copy</span><span class=p>(</span><span class=nx>newSlice</span><span class=p>,</span> <span class=nx>slice</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>slice</span> <span class=p>=</span> <span class=nx>newSlice</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>slice</span> <span class=p>=</span> <span class=nx>slice</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=nx>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nb>copy</span><span class=p>(</span><span class=nx>slice</span><span class=p>[</span><span class=nx>m</span><span class=p>:</span><span class=nx>n</span><span class=p>],</span> <span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>slice</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以这样使用 AppendByte：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>p</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>p</span> <span class=p>=</span> <span class=nf>AppendByte</span><span class=p>(</span><span class=nx>p</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>13</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// p == []byte{2, 3, 5, 7, 11, 13}
</span></span></span></code></pre></div><p>像 AppendByte 这样的函数很有用，因为它们提供了对切片增长方式的完全控制。根据程序的特点，可能需要分配更小或更大的块，或对重新分配的大小设置一个上限。</p><p>但是大多数程序不需要完全控制，所以Go提供了一个内置的 append 函数，这对大多数目的都很好;它有签名:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=nx>T</span><span class=p>,</span> <span class=nx>x</span> <span class=o>...</span><span class=nx>T</span><span class=p>)</span> <span class=p>[]</span><span class=nx>T</span>
</span></span></code></pre></div><p>append 函数将元素x追加到切片s的末尾，如果需要更大的容量，则会增长切片。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>a</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// a == []int{0}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// a == []int{0, 1, 2, 3}
</span></span></span></code></pre></div><p>要将一个切片附加到另一个切片，使用…将第二个参数拓展为一个参数列表。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>a</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;John&#34;</span><span class=p>,</span> <span class=s>&#34;Paul&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;George&#34;</span><span class=p>,</span> <span class=s>&#34;Ringo&#34;</span><span class=p>,</span> <span class=s>&#34;Pete&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=o>...</span><span class=p>)</span> <span class=c1>// equivalent to &#34;append(a, b[0], b[1], b[2])&#34;
</span></span></span><span class=line><span class=cl><span class=c1>// a == []string{&#34;John&#34;, &#34;Paul&#34;, &#34;George&#34;, &#34;Ringo&#34;, &#34;Pete&#34;}
</span></span></span></code></pre></div><p>因为切片的零值(nil)就像一个零长度的切片，你可以声明一个切片变量，然后在循环中添加它:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Filter returns a new slice holding only
</span></span></span><span class=line><span class=cl><span class=c1>// the elements of s that satisfy fn()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Filter</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>fn</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>p</span> <span class=p>[]</span><span class=kt>int</span> <span class=c1>// == nil
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nf>fn</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>p</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>p</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>p</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=一个可能的陷阱>一个可能的“陷阱”<a href=#一个可能的陷阱 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>如前所述，重新切片并不会生成底层数组的副本。整个数组将保存在内存中，直到它不再被引用。有时，这可能导致程序将所有数据保存在内存中，而实际上只需要一小部分数据。</p><p>例如，FindDigits 函数将一个文件加载到内存中，并在其中搜索第一组连续的数字，将它们作为一个新片返回。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>digitRegexp</span> <span class=p>=</span> <span class=nx>regexp</span><span class=p>.</span><span class=nf>MustCompile</span><span class=p>(</span><span class=s>&#34;[0-9]+&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>FindDigits</span><span class=p>(</span><span class=nx>filename</span> <span class=kt>string</span><span class=p>)</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>digitRegexp</span><span class=p>.</span><span class=nf>Find</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>此代码的行为与所宣传的一样，但返回的[]byte指向包含整个文件的数组。由于切片引用原始数组，只要切片被保留在垃圾收集器周围，就不能释放数组;文件的几个有用字节将整个内容保存在内存中。</p><p>为了解决这个问题，你可以在返回之前将感兴趣的数据复制到一个新的切片:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>CopyDigits</span><span class=p>(</span><span class=nx>filename</span> <span class=kt>string</span><span class=p>)</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span> <span class=p>=</span> <span class=nx>digitRegexp</span><span class=p>.</span><span class=nf>Find</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nb>copy</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个函数的一个更简洁的版本可以通过使用 append 构造。</p></div></main><footer id=site-footer class="section-inner thin animated fadeIn faster"><p>&copy; 2022 <a href=https://lqgl.cool>Lqgl</a> &#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></p><p>Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> &#183; Theme <a href=https://github.com/Track3/hermit target=_blank rel=noopener>Hermit</a> &#183; <a href=https://lqgl.cool/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></p></footer><script src=https://lqgl.cool/js/bundle.min.580988ed2982bcbb74a1773c7abea97b43e4c43b9324e10cda0813ec6ec4bb67.js integrity="sha256-WAmI7SmCvLt0oXc8er6pe0PkxDuTJOEM2ggT7G7Eu2c=" crossorigin=anonymous></script></body><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?50c3f3ef571621033fd843f7a435fa32",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></html>