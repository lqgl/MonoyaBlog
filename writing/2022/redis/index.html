<!doctype html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=color-scheme content="dark light"><meta name=theme-color content="#54BAB9"><meta name=msapplication-TileColor content="#54BAB9"><meta name=description content="Redis 是什么？ #Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作。 因为是纯内存操作，Redis 的性能"><meta itemprop=name content="Redis"><meta itemprop=description content="Redis 是什么？ #Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作。 因为是纯内存操作，Redis 的性能"><meta itemprop=datePublished content="2022-09-29T11:25:04+08:00"><meta itemprop=dateModified content="2022-09-29T11:25:04+08:00"><meta itemprop=wordCount content="2179"><meta itemprop=image content="https://lqgl.asia/apple-touch-icon.png"><meta itemprop=keywords content="Database,Redis,"><meta property="og:title" content="Redis"><meta property="og:description" content="Redis 是什么？ #Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作。 因为是纯内存操作，Redis 的性能"><meta property="og:type" content="article"><meta property="og:url" content="https://lqgl.asia/writing/2022/redis/"><meta property="og:image" content="https://lqgl.asia/apple-touch-icon.png"><meta property="article:section" content="writing"><meta property="article:published_time" content="2022-09-29T11:25:04+08:00"><meta property="article:modified_time" content="2022-09-29T11:25:04+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lqgl.asia/apple-touch-icon.png"><meta name=twitter:title content="Redis"><meta name=twitter:description content="Redis 是什么？ #Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作。 因为是纯内存操作，Redis 的性能"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#54bab9><link rel="shortcut icon" href=/favicon.ico><title>Redis</title>
<link rel=dns-prefetch href=//cdn.jsdelivr.net><link rel=stylesheet href=https://lqgl.asia/css/style.min.7cf192d60a2f0f4422ad86d96853ba8ff16c2f7ae673d20e432e6e488e021055.css integrity="sha256-fPGS1govD0QirYbZaFO6j/FsL3rmc9IOQy5uSI4CEFU="></head><body><div id=page><header id=site-header><div id=site-branding><a href=https://lqgl.asia/>Kami's Planet</a></div><nav id=site-nav><a href=/writing>Writing</a>
<a href=/gallery>Gallery</a>
<a href=/link>Link</a>
<a href=/about>About</a></nav></header><main id=site-main class=wrapper><article><header class=post-header><div class=title-area><a id=home-btn title="Kami's Planet" href=https://lqgl.asia/><img src=/apple-touch-icon.png width=180 height=180 alt=Logo></a><div class=title-area-l><div id=post-header-date>Sep 29, 2022</div><h1 id=page-title>Redis</h1></div></div><button id=toc-btn title=目录><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3" y2="6"/><line x1="3" y1="12" x2="3" y2="12"/><line x1="3" y1="18" x2="3" y2="18"/></svg> 目录</button></header><div id=toc class=sidebar><p class=toc-title>目录</p><nav id=TableOfContents><ul><li><a href=#redis-是什么>Redis 是什么？</a></li><li><a href=#使用-redis-有哪些好处>使用 redis 有哪些好处？</a></li><li><a href=#memcached-与-redis-的区别都有哪些>Memcached 与 Redis 的区别都有哪些？</a></li><li><a href=#redis-相比-memcached-有哪些优势>redis 相比 memcached 有哪些优势？</a></li><li><a href=#为什么用-redis>为什么用 redis</a></li><li><a href=#redis-的持久化机制是什么各自的优缺点>Redis 的持久化机制是什么？各自的优缺点？</a><ul><li><a href=#rdb是-redis-database-缩写快照>RDB：是 Redis DataBase 缩写快照</a></li><li><a href=#aof持久化>AOF：持久化：</a></li></ul></li><li><a href=#redis-的过期策略和内存淘汰机制>Redis 的过期策略和内存淘汰机制</a><ul><li><a href=#过期策略>过期策略</a></li><li><a href=#内存淘汰机制>内存淘汰机制</a></li></ul></li><li><a href=#redis-主要消耗什么物理资源>Redis 主要消耗什么物理资源？</a></li><li><a href=#redis-的内存用完了会发生什么>Redis 的内存用完了会发生什么？</a></li><li><a href=#缓存穿透和缓存雪崩>缓存穿透和缓存雪崩</a><ul><li><a href=#缓存穿透>缓存穿透</a></li><li><a href=#缓存雪崩>缓存雪崩</a></li></ul></li><li><a href=#mysql-里有-2000w-数据redis-中只存-20w-的数据如何保证-redis-中的数据都是热点数据>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据</a></li></ul></nav></div><div class=content><h2 id=redis-是什么>Redis 是什么？ <a href=#redis-%e6%98%af%e4%bb%80%e4%b9%88 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作。</p><p>因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。</p><p>Redis 可以用来实现很多有用的功能:</p><ol><li><p>用它的 List 来做 FIFO 双向链表，实现一个轻量级的高性能消息队列服务</p></li><li><p>用它的 Set 可以做高性能的 tag 系统</p></li><li><p>Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用</p></li></ol><h2 id=使用-redis-有哪些好处>使用 redis 有哪些好处？ <a href=#%e4%bd%bf%e7%94%a8-redis-%e6%9c%89%e5%93%aa%e4%ba%9b%e5%a5%bd%e5%a4%84 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><p>速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O (1)</p><p>支持丰富数据类型，支持 string，list，set，zset，hash</p><p>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p><p>丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除</p><h2 id=memcached-与-redis-的区别都有哪些>Memcached 与 Redis 的区别都有哪些？ <a href=#memcached-%e4%b8%8e-redis-%e7%9a%84%e5%8c%ba%e5%88%ab%e9%83%bd%e6%9c%89%e5%93%aa%e4%ba%9b class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><ol><li><p>存储方式: Memcached 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis 有部份存在硬盘上，这样能保证数据的持久性。</p></li><li><p>数据支持类型: Memcached 对数据类型支持相对简单。 Redis 有复杂的数据类型。</p></li></ol><h2 id=redis-相比-memcached-有哪些优势>redis 相比 memcached 有哪些优势？ <a href=#redis-%e7%9b%b8%e6%af%94-memcached-%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bc%98%e5%8a%bf class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><ol><li><p>memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型</p></li><li><p>redis 的速度比 memcached 快很多</p></li><li><p>redis 可以持久化其数据</p></li></ol><h2 id=为什么用-redis>为什么用 redis <a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%94%a8-redis class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><h2 id=redis-的持久化机制是什么各自的优缺点>Redis 的持久化机制是什么？各自的优缺点？ <a href=#redis-%e7%9a%84%e6%8c%81%e4%b9%85%e5%8c%96%e6%9c%ba%e5%88%b6%e6%98%af%e4%bb%80%e4%b9%88%e5%90%84%e8%87%aa%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><h3 id=rdb是-redis-database-缩写快照>RDB：是 Redis DataBase 缩写快照 <a href=#rdb%e6%98%af-redis-database-%e7%bc%a9%e5%86%99%e5%bf%ab%e7%85%a7 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>RDB 是 Redis 默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为 dump.rdb。通过配置文件中的 save 参数来定义快照的周期。</p><ol><li><p>只有一个文件 dump.rdb，方便持久化。</p></li><li><p>容灾性好，一个文件可以保存到安全的磁盘</p></li></ol><h3 id=aof持久化>AOF：持久化： <a href=#aof%e6%8c%81%e4%b9%85%e5%8c%96 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>AOF 持久化 (即 Append Only File 持久化)，则是将 Redis 执行的每次写命令记录到单独的日志文件中，当重启 Redis 会重新将持久化的日志中文件恢复数据。</p><h2 id=redis-的过期策略和内存淘汰机制>Redis 的过期策略和内存淘汰机制 <a href=#redis-%e7%9a%84%e8%bf%87%e6%9c%9f%e7%ad%96%e7%95%a5%e5%92%8c%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e6%9c%ba%e5%88%b6 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><h3 id=过期策略>过期策略 <a href=#%e8%bf%87%e6%9c%9f%e7%ad%96%e7%95%a5 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>redis 采用的是定期删除 + 惰性删除策略</p><p>定期删除，redis 默认每个 100ms 检查，是否有过期的 key, 有过期 key 则删除。需要说明的是，redis 不是每个 100ms 将所有的 key 检查一次，而是随机抽取进行检查 (如果每隔 100ms, 全部 key 进行检查，redis 岂不是卡死)。因此，如果只采用定期删除策略，会导致很多 key 到时间没有删除。</p><p>于是，惰性删除派上用场。也就是说在你获取某个 key 的时候，redis 会检查一下，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p><h3 id=内存淘汰机制>内存淘汰机制 <a href=#%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e6%9c%ba%e5%88%b6 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>如果定期删除没删除 key。然后你也没即时去请求 key，也就是说惰性删除也没生效。这样，redis 的内存会越来越高。那么就应该采用内存淘汰机制。
在 redis.conf 中有一行配置</p><pre tabindex=0><code class=language-conf data-lang=conf># maxmemory-policy volatile-lru
</code></pre><p>该配置就是配内存淘汰策略的</p><ol><li><p>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。</p></li><li><p>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key。推荐使用，目前项目在用这种。</p></li><li><p>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key。应该也没人用吧，你不删最少使用 Key, 去随机删。</p></li><li><p>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key。这种情况一般是把 redis 既当缓存，又做持久化存储的时候才用。不推荐</p></li><li><p>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。依然不推荐</p></li><li><p>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。不推荐</p></li></ol><h2 id=redis-主要消耗什么物理资源>Redis 主要消耗什么物理资源？ <a href=#redis-%e4%b8%bb%e8%a6%81%e6%b6%88%e8%80%97%e4%bb%80%e4%b9%88%e7%89%a9%e7%90%86%e8%b5%84%e6%ba%90 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><p>内存</p><h2 id=redis-的内存用完了会发生什么>Redis 的内存用完了会发生什么？ <a href=#redis-%e7%9a%84%e5%86%85%e5%ad%98%e7%94%a8%e5%ae%8c%e4%ba%86%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><p>如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。</p><h2 id=缓存穿透和缓存雪崩>缓存穿透和缓存雪崩 <a href=#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f%e5%92%8c%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><h3 id=缓存穿透>缓存穿透 <a href=#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p><h3 id=缓存雪崩>缓存雪崩 <a href=#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。
使缓存集中失效的原因：</p><ol><li><p>redis服务器挂掉了。</p></li><li><p>对缓存数据设置了相同的过期时间，导致某时间段内缓存集中失效。</p></li></ol><p>如何解决缓存集中失效：</p><ol><li><p>针对原因1，可以实现redis的高可用，Redis Cluster 或者 Redis Sentinel(哨兵) 等方案。</p></li><li><p>针对原因2，设置缓存过期时间时加上一个随机值，避免缓存在同一时间过期。</p></li><li><p>使用双缓存策略，设置两个缓存，原始缓存和备用缓存，原始缓存失效时，访问备用缓存，备用缓存失效时间设置长点。</p></li></ol><h2 id=mysql-里有-2000w-数据redis-中只存-20w-的数据如何保证-redis-中的数据都是热点数据>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据 <a href=#mysql-%e9%87%8c%e6%9c%89-2000w-%e6%95%b0%e6%8d%aeredis-%e4%b8%ad%e5%8f%aa%e5%ad%98-20w-%e7%9a%84%e6%95%b0%e6%8d%ae%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81-redis-%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e9%83%bd%e6%98%af%e7%83%ad%e7%82%b9%e6%95%b0%e6%8d%ae class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。
可以设置成最近最少使用的数据淘汰。</p></div><hr class=post-end><footer class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://lqgl.asia/tags/database>Database</a></span><span class=tag><a href=https://lqgl.asia/tags/redis>Redis</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>2179 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2022-09-29 03:25</p></footer></article><div class=post-nav><a class=next-post href=https://lqgl.asia/writing/2022/mysql-operations/><span class=post-nav-label><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>&nbsp;Newer</span><br><span>MySQL 数据库操作</span>
</a><a class=prev-post href=https://lqgl.asia/writing/2022/docker-usage/><span class=post-nav-label>Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></span><br><span>Docker 安装卸载与镜像容器管理</span></a></div><button type=button id=scroll-top-btn title=回到顶部><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-up-circle"><circle cx="12" cy="12" r="10"/><polyline points="16 12 12 8 8 12"/><line x1="12" y1="16" x2="12" y2="8"/></svg></button>
<script src=https://giscus.app/client.js data-repo=lqgl/blog data-repo-id="MDEwOlJlcG9zaXRvcnk0MDc1ODU3NjY=" data-category=Announcements data-category-id=DIC_kwDOGEtD5s4CRp8B data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></main><footer id=site-footer class=wrapper><div class=footer-inner><div class=footer-l><nav class=site-nav><a href=https://lqgl.asia/>Home</a><span>/</span><a href=/writing>Writing</a><span>/</span><a href=/gallery>Gallery</a><span>/</span><a href=/link>Link</a><span>/</span><a href=/about>About</a><span>/</span></nav></div><div class=footer-r><p class=site-copy>&copy; 2024 <a href=https://lqgl.asia/>Kami</a> &#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/deed.zh target=_blank rel=noopener>CC BY-NC 4.0</a> &#183; <a href=https://lqgl.asia/writing/index.xml target=_blank title=RSS class=icon-link><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></p></div></div></footer><div class=sakana-box></div><script src=https://cdn.jsdelivr.net/npm/sakana></script><script>Sakana.init({el:".sakana-box",character:"chisato",inertia:.01,decay:.99,r:60,y:10,scale:.4,translateY:0,canSwitchCharacter:!1})</script></div><canvas class=fireworks style=position:fixed;left:0;top:0;z-index:1;pointer-events:none></canvas>
<script type=text/javascript src=/js/anime.min.js></script><script type=text/javascript src=/js/firework.js></script><div id=bg-img></div><script src=https://lqgl.asia/js/bundle.min.e36dd6c5d8e05fc3cdd1d4104862780595ffa4df1ebd31a1e814f58799b49568.js integrity="sha256-423WxdjgX8PN0dQQSGJ4BZX/pN8evTGh6BT1h5m0lWg=" crossorigin=anonymous></script><script src=/js/instant.page-5.1.1.js type=module integrity=sha384-MWfCL6g1OTGsbSwfuMHc8+8J2u71/LA8dzlIN3ycajckxuZZmF+DNjdm7O6H3PSq></script></body></html>