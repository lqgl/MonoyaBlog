<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=color-scheme content="dark light"><meta name=theme-color content="#54BAB9"><meta name=msapplication-TileColor content="#54BAB9"><meta name=description content="排序算法可以分为内部排序和外部排序。 内部排序是数据记录在内存中进行排序。 而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程"><meta itemprop=name content="经典排序算法"><meta itemprop=description content="排序算法可以分为内部排序和外部排序。 内部排序是数据记录在内存中进行排序。 而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程"><meta itemprop=datePublished content="2022-10-08T10:00:59+08:00"><meta itemprop=dateModified content="2022-10-08T10:00:59+08:00"><meta itemprop=wordCount content="3484"><meta itemprop=image content="https://lqgl.cool/apple-touch-icon.png"><meta itemprop=keywords content="Algorithm,Go,"><meta property="og:title" content="经典排序算法"><meta property="og:description" content="排序算法可以分为内部排序和外部排序。 内部排序是数据记录在内存中进行排序。 而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程"><meta property="og:type" content="article"><meta property="og:url" content="https://lqgl.cool/writing/2022/classic-sorting-algorithms/"><meta property="og:image" content="https://lqgl.cool/apple-touch-icon.png"><meta property="article:section" content="writing"><meta property="article:published_time" content="2022-10-08T10:00:59+08:00"><meta property="article:modified_time" content="2022-10-08T10:00:59+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lqgl.cool/apple-touch-icon.png"><meta name=twitter:title content="经典排序算法"><meta name=twitter:description content="排序算法可以分为内部排序和外部排序。 内部排序是数据记录在内存中进行排序。 而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程"><link rel=apple-touch-icon sizes=180x180 href=../../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../../favicon-16x16.png><link rel=manifest href=../../../site.webmanifest><link rel=mask-icon href=../../../safari-pinned-tab.svg color=#54bab9><link rel="shortcut icon" href=../../../favicon.ico><title>经典排序算法</title><link rel=dns-prefetch href=//cdn.jsdelivr.net><link rel=stylesheet href=https://lqgl.cool/css/style.min.7cf192d60a2f0f4422ad86d96853ba8ff16c2f7ae673d20e432e6e488e021055.css integrity="sha256-fPGS1govD0QirYbZaFO6j/FsL3rmc9IOQy5uSI4CEFU="></head><body><div id=page><header id=site-header><div id=site-branding><a href=https://lqgl.cool>Kami's Planet</a></div><nav id=site-nav><a href=../../../writing>Writing</a>
<a href=../../../gallery>Gallery</a>
<a href=../../../link>Link</a>
<a href=../../../about>About</a></nav></header><main id=site-main class=wrapper><article><header class=post-header><div class=title-area><a id=home-btn title="Kami's Planet" href=https://lqgl.cool><img src=../../../apple-touch-icon.png width=180 height=180 alt=Logo></a><div class=title-area-l><div id=post-header-date>Oct 8, 2022</div><h1 id=page-title>经典排序算法</h1></div></div><button id=toc-btn title=目录><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3" y2="6"/><line x1="3" y1="12" x2="3" y2="12"/><line x1="3" y1="18" x2="3" y2="18"/></svg> 目录</button></header><div id=toc class=sidebar><p class=toc-title>目录</p><nav id=TableOfContents><ul><li><a href=#稳定性>稳定性</a></li><li><a href=#冒泡排序>冒泡排序</a><ul><li><a href=#算法思想>算法思想</a></li><li><a href=#代码实现>代码实现</a></li></ul></li><li><a href=#选择排序>选择排序</a><ul><li><a href=#算法思想-1>算法思想</a></li><li><a href=#代码实现-1>代码实现</a></li></ul></li><li><a href=#插入排序>插入排序</a><ul><li><a href=#算法思想-2>算法思想</a></li><li><a href=#代码实现-2>代码实现</a></li></ul></li><li><a href=#希尔排序>希尔排序</a><ul><li><a href=#算法思想-3>算法思想</a></li><li><a href=#代码实现-3>代码实现</a></li></ul></li><li><a href=#归并排序>归并排序</a><ul><li><a href=#算法思想-4>算法思想</a></li><li><a href=#代码实现-4>代码实现</a></li></ul></li><li><a href=#快速排序>快速排序</a><ul><li><a href=#算法思想-5>算法思想</a></li><li><a href=#代码实现-5>代码实现</a></li></ul></li><li><a href=#堆排序>堆排序</a><ul><li><a href=#算法思想-6>算法思想</a></li><li><a href=#代码实现-6>代码实现</a></li></ul></li><li><a href=#计数排序>计数排序</a><ul><li><a href=#算法思想-7>算法思想</a></li><li><a href=#代码实现-7>代码实现</a></li></ul></li><li><a href=#桶排序>桶排序</a><ul><li><a href=#算法思想-8>算法思想</a></li><li><a href=#代码实现-8>代码实现</a></li></ul></li><li><a href=#基数排序>基数排序</a><ul><li><a href=#算法思想-9>算法思想</a></li><li><a href=#代码实现-9>代码实现</a></li></ul></li></ul></nav></div><div class=content><p>排序算法可以分为内部排序和外部排序。</p><p>内部排序是数据记录在内存中进行排序。</p><p>而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p><p>常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p><img src=sort.png width=1200px><h2 id=稳定性>稳定性 <a href=#%e7%a8%b3%e5%ae%9a%e6%80%a7 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><ol><li><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p></li><li><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p></li></ol><h2 id=冒泡排序>冒泡排序 <a href=#%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><h3 id=算法思想>算法思想 <a href=#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>从第一个和第二个开始比较，如果第一个比第二个大，则交换位置，然后比较第二个和第三个，逐渐往后，经过第一轮后最大的元素已经排在最后，</p><p>所以重复上述操作的话第二大的则会排在倒数第二的位置。那重复上述操作 n-1 次即可完成排序，因为最后一次只有一个元素所以不需要比较。</p><img src=bubble-sort.gif><h3 id=代码实现>代码实现 <a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// BubbleSort 冒泡排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>BubbleSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int32</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 第一层 for 表示循环的遍数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 第二层 for 表示具体比较哪两个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 如果前面的大于后面的，则交换这两个元素的位置
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>arr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=选择排序>选择排序 <a href=#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><h3 id=算法思想-1>算法思想 <a href=#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-1 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>设第一个元素为比较元素，依次和后面的元素比较，比较完所有元素找到最小的元素，将它和第一个元素互换，
重复上述操作，我们找出第二小的元素和第二个位置的元素互换，以此类推找出剩余最小元素将它换到前面，即完成排序。</p><img src=selection-sort.gif><h3 id=代码实现-1>代码实现 <a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// SelectionSort 选择排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>SelectionSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int32</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 第一层 for 表示循环选择的遍数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 起始元素设为最小的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>minIndex</span> <span class=o>:=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 第二层 for 表示最小元素与后面的元素逐个比较
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>minIndex</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>// 如果当前元素比最小元素小，则把当前元素角标记为最小元素角标
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=nx>minIndex</span> <span class=p>=</span> <span class=nx>j</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 查找一遍后将最小元素与起始元素互换
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>arr</span><span class=p>[</span><span class=nx>minIndex</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>minIndex</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>arr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=插入排序>插入排序 <a href=#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><h3 id=算法思想-2>算法思想 <a href=#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-2 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>从第二个元素开始和前面的元素进行比较，如果前面的元素比当前元素大，则将前面元素 后移，当前元素依次往前，直到找到比它小或等于它的元素插入在其后面，</p><p>然后选择第三个元素，重复上述操作，进行插入，依次选择到最后一个元素，插入后即完成所有排序。</p><img src=insertion-sort.gif><h3 id=代码实现-2>代码实现 <a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// InsertionSort 插入排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>InsertionSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int32</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 第一层 for 表示循环插入的遍数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 设置当前需要插入的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>current</span> <span class=o>:=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 与当前元素比较的比较元素
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>preIndex</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>preIndex</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>preIndex</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>current</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 当比较元素大于当前元素则把比较元素后移
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>arr</span><span class=p>[</span><span class=nx>preIndex</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>preIndex</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 往前选择下一个比较元素
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>preIndex</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 当比较元素小于当前元素，则将当前元素插入在其后面
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>arr</span><span class=p>[</span><span class=nx>preIndex</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=nx>current</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>arr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=希尔排序>希尔排序 <a href=#%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><h3 id=算法思想-3>算法思想 <a href=#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-3 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>希尔排序的整体思想是将固定间隔的几个元素之间排序，然后再缩小这个间隔。这样到最后数列就成为了基本有序数列。</p><p>具体步骤：</p><ol><li><p>计算一个增量（间隔）值</p></li><li><p>对元素进行增量元素进行比较，比如增量值为 7，那么就对 0,7,14,21… 个元素进行插入排序</p></li><li><p>然后对 1,8,15… 进行排序，依次递增进行排序</p></li><li><p>所有元素排序完后，缩小增量比如为 3，然后又重复上述第 2，3 步</p></li><li><p>最后缩小增量至 1 时，数列已经基本有序，最后一遍普通插入即可</p></li></ol><img src=shell-sort.gif><h3 id=代码实现-3>代码实现 <a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-3 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ShellSort 希尔排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>ShellSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int32</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 取整计算增量（间隔）值
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gap</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>gap</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 从增量值开始遍历比较
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>gap</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>current</span> <span class=o>:=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 元素与他同列的前面的每个元素比较，如果比前面的小则互换
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>preIndex</span> <span class=o>:=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=nx>preIndex</span><span class=o>-</span><span class=nx>gap</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>current</span> <span class=p>&lt;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>preIndex</span><span class=o>-</span><span class=nx>gap</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>arr</span><span class=p>[</span><span class=nx>preIndex</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>preIndex</span><span class=o>-</span><span class=nx>gap</span><span class=p>]</span>
</span></span><span class=line><span class=cl>				<span class=nx>preIndex</span> <span class=o>-=</span> <span class=nx>gap</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>arr</span><span class=p>[</span><span class=nx>preIndex</span><span class=p>]</span> <span class=p>=</span> <span class=nx>current</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 缩小增量（间隔）值
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>gap</span> <span class=o>/=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>arr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=归并排序>归并排序 <a href=#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><h3 id=算法思想-4>算法思想 <a href=#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-4 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>归并排序是分治法的典型应用。分治法（Divide-and-Conquer）：将原问题划分成 n 个规模较小而结构与原问题相似的子问题；递归地解决这些问题，然后再合并其结果，就得到原问题的解，分解后的数列很像一个二叉树。</p><p>具体实现步骤：</p><ol><li><p>使用递归将源数列使用二分法分成多个子列</p></li><li><p>申请空间将两个子列排序合并然后返回</p></li><li><p>将所有子列一步一步合并最后完成排序</p></li><li><p>注：先分解再归并</p></li></ol><img src=merge-sort.gif><h3 id=代码实现-4>代码实现 <a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-4 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// MergeSort 归并排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>MergeSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int32</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>arr</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 使用二分法将数列分两个
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>mid</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>	<span class=nx>left</span> <span class=o>:=</span> <span class=nx>arr</span><span class=p>[:</span><span class=nx>mid</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=nx>right</span> <span class=o>:=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>mid</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 使用递归运算
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nf>merge</span><span class=p>(</span><span class=nf>MergeSort</span><span class=p>(</span><span class=nx>left</span><span class=p>),</span> <span class=nf>MergeSort</span><span class=p>(</span><span class=nx>right</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 排序合并
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>merge</span><span class=p>(</span><span class=nx>left</span> <span class=p>[]</span><span class=kt>int32</span><span class=p>,</span> <span class=nx>right</span> <span class=p>[]</span><span class=kt>int32</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 排序合并两个数列
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>result</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int32</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 两个数列都有值
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>left</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>right</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 左右两个数列第一个最小放前面
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>left</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=nx>right</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>head</span> <span class=o>:=</span> <span class=nx>left</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>head</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>left</span> <span class=p>=</span> <span class=nx>left</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>head</span> <span class=o>:=</span> <span class=nx>right</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>head</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>right</span> <span class=p>=</span> <span class=nx>right</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 只有一个数列中还有值，直接添加
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>left</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>right</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>result</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=快速排序>快速排序 <a href=#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><h3 id=算法思想-5>算法思想 <a href=#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-5 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>找出基线条件，这种条件必须尽可能简单，不断将问题分解（或者说缩小规模），直到符合基线条件。</p><p>具体实现步骤：</p><ol><li><p>先从数列中取出一个数作为基准数。</p></li><li><p>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p></li><li><p>再对左右区间重复第二步，直到各区间只有一个数。</p></li></ol><img src=quick-sort.gif><h3 id=代码实现-5>代码实现 <a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-5 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// QuickSort 快速排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>QuickSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int32</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=p>&lt;</span> <span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 基线条件：为空或只包含一个元素的数组是 “有序” 的
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=nx>arr</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 递归条件
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>pivot</span> <span class=o>:=</span> <span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>less</span><span class=p>,</span> <span class=nx>greater</span> <span class=p>[]</span><span class=kt>int32</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>val</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>arr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>val</span> <span class=o>&lt;=</span> <span class=nx>pivot</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 由所有小于基准值的元素组成的子数组
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>less</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>less</span><span class=p>,</span> <span class=nx>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 由所有大于基准值的元素组成的子数组
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>greater</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>greater</span><span class=p>,</span> <span class=nx>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>append</span><span class=p>(</span><span class=nb>append</span><span class=p>(</span><span class=nf>QuickSort</span><span class=p>(</span><span class=nx>less</span><span class=p>),</span> <span class=nx>pivot</span><span class=p>),</span> <span class=nf>QuickSort</span><span class=p>(</span><span class=nx>greater</span><span class=p>)</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=堆排序>堆排序 <a href=#%e5%a0%86%e6%8e%92%e5%ba%8f class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><h3 id=算法思想-6>算法思想 <a href=#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-6 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>堆分为最大堆和最小堆，是完全二叉树。堆排序就是把堆顶的最大数取出，将剩余的堆继续调整为最大堆，具体过程在第二块有介绍，以递归实现，</p><p>剩余部分调整为最大堆后，再次将堆顶的最大数取出，再将剩余部分调整为最大堆，这个过程持续到剩余数只有一个时结束。</p><img src=heap-sort.gif><h3 id=代码实现-6>代码实现 <a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-6 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// HeapSort 堆排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>HeapSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int32</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 第一下 使得第一个元素最小，接下来就从第二个来构造，使得下一个最小，
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>heapify</span><span class=p>(</span><span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>arr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 建堆
</span></span></span><span class=line><span class=cl><span class=c1>// 每次操作完毕 堆顶的元素就是最小的，由于堆的特性，我们只需要从倒数第二层开始就可以了
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>heapify</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>length</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>floor</span> <span class=o>:=</span> <span class=nx>length</span><span class=o>/</span><span class=mi>2</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>floor</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 然后比较的每一个节点与其两个孩子节点的大小，使得根节点永远是最小的
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 有一种特殊情况，就是最后一个节点的孩子节点可能不存在，和可能只有一个，所以需要加上一个判断
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>root</span> <span class=o>:=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>		<span class=nx>left</span> <span class=o>:=</span> <span class=mi>2</span><span class=o>*</span><span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span>  <span class=c1>// 左节点
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>right</span> <span class=o>:=</span> <span class=mi>2</span><span class=o>*</span><span class=nx>i</span> <span class=o>+</span> <span class=mi>2</span> <span class=c1>// 右节点
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>right</span> <span class=p>&lt;</span> <span class=nx>length</span> <span class=o>&amp;&amp;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>right</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>root</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>root</span> <span class=p>=</span> <span class=nx>right</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>left</span> <span class=p>&lt;</span> <span class=nx>length</span> <span class=o>&amp;&amp;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>left</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>root</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>root</span> <span class=p>=</span> <span class=nx>left</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// 把父节点换下去并向下调整
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>root</span> <span class=o>!=</span> <span class=nx>i</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>arr</span><span class=p>[</span><span class=nx>root</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>root</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=计数排序>计数排序 <a href=#%e8%ae%a1%e6%95%b0%e6%8e%92%e5%ba%8f class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><h3 id=算法思想-7>算法思想 <a href=#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-7 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>对每一个输入元素 x，确定小于 x 的元素个数。利用这一信息，就可以直接把 x 放在它在输出数组上的位置上了，运行时间为 O (n)，但其需要的空间不一定，空间浪费大。</p><p>具体实现步骤：</p><ol><li><p>找出待排序的数组中最大和最小的元素</p></li><li><p>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</p></li><li><p>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</p></li><li><p>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p></li></ol><img src=count-sort.gif><h3 id=代码实现-7>代码实现 <a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-7 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// CountingSort 计数排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>CountingSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int32</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>max</span> <span class=o>:=</span> <span class=nf>getMax</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span>              <span class=c1>// 获取最大值
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>counter</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int32</span><span class=p>,</span> <span class=nx>max</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=c1>// 用于统计个数的空数组
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sortedIndex</span> <span class=o>:=</span> <span class=mi>0</span>                <span class=c1>// 桶内索引值
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>counter</span><span class=p>[</span><span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]]</span> <span class=o>+=</span> <span class=mi>1</span> <span class=c1>// 统计每个元素出现的次数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>counter</span><span class=p>);</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>counter</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>arr</span><span class=p>[</span><span class=nx>sortedIndex</span><span class=p>]</span> <span class=p>=</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>j</span><span class=p>)</span> <span class=c1>// 取出元素
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>sortedIndex</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>			<span class=nx>counter</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>arr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 获取最大值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>getMax</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int32</span><span class=p>)</span> <span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>max</span> <span class=o>:=</span> <span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>val</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>arr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>val</span> <span class=p>&gt;</span> <span class=nx>max</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>max</span> <span class=p>=</span> <span class=nx>val</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>max</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=桶排序>桶排序 <a href=#%e6%a1%b6%e6%8e%92%e5%ba%8f class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><h3 id=算法思想-8>算法思想 <a href=#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-8 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>为了节省空间和时间，我们需要指定要排序的数据中最小以及最大的数字的值，来方便桶排序算法的运算。</p><p>桶排序的算法原理：</p><ol><li><p>设置一个定量的数组当作空桶子.</p></li><li><p>寻访序列，并且把项目一个一个放到对应的桶子去.</p></li><li><p>对每个不是空的桶子进行排序.</p></li><li><p>从不是空的桶子里把项目再放回原来的序列中.</p></li></ol><img src=bucket-sort.gif><h3 id=代码实现-8>代码实现 <a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-8 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// BucketSort 桶排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>BucketSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 原数列的最大值与最小值
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>max</span><span class=p>,</span> <span class=nx>min</span> <span class=o>:=</span> <span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>val</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>arr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>val</span> <span class=p>&gt;</span> <span class=nx>max</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>max</span> <span class=p>=</span> <span class=nx>val</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>val</span> <span class=p>&lt;</span> <span class=nx>min</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>min</span> <span class=p>=</span> <span class=nx>val</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 这里设置每个桶的容量是5
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>bucketCapacity</span> <span class=o>:=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 计算所需桶的个数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>bucketCount</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>max</span> <span class=o>-</span> <span class=nx>min</span> <span class=o>+</span> <span class=nx>bucketCapacity</span><span class=p>)</span> <span class=o>/</span> <span class=nx>bucketCapacity</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>buckets</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([][]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>bucketCount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>bucketCount</span><span class=p>;</span> <span class=nx>i</span> <span class=o>+=</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>bucket</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 初始化桶
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>buckets</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>buckets</span><span class=p>,</span> <span class=nx>bucket</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>arr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 映射函数
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>k</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>n</span> <span class=o>-</span> <span class=nx>min</span><span class=p>)</span> <span class=o>/</span> <span class=nx>bucketCapacity</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 分配入桶
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>buckets</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>buckets</span><span class=p>[</span><span class=nx>k</span><span class=p>],</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>p</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>bucket</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>buckets</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>bucket</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 给每个桶中的元素排序
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>sort</span><span class=p>.</span><span class=nf>Ints</span><span class=p>(</span><span class=nx>bucket</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 将桶中的元素赋值到原序列
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>bucket</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>arr</span><span class=p>[</span><span class=nx>p</span><span class=p>]</span> <span class=p>=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>			<span class=nx>p</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>arr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=基数排序>基数排序 <a href=#%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h2><h3 id=算法思想-9>算法思想 <a href=#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-9 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><p>基数排序（radix sort）属于 “分配式排序”（distribution sort），又称 “桶子法”（bucket sort）或 bin sort，
顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些 “桶” 中，藉以达到排序的作用，基数排序法是属于稳定性的排序，
其时间复杂度为 O (nlog (r) m)，其中 r 为所采取的基数，而 m 为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p><img src=radix-sort.gif><h3 id=代码实现-9>代码实现 <a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-9 class=anchor aria-hidden=true><span class=anchor-icon>#</span></a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// RadixSort 基数排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>RadixSort</span><span class=p>(</span><span class=nx>array</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>digit</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>max</span> <span class=o>:=</span> <span class=nx>math</span><span class=p>.</span><span class=nx>MinInt32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>val</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>array</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>val</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span> <span class=c1>// 输入可能为负数，取绝对值
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>val</span> <span class=p>=</span> <span class=o>-</span><span class=nx>val</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 取最大值来判断目前是否已经看到最高位数
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>max</span> <span class=p>&lt;</span> <span class=nx>val</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>max</span> <span class=p>=</span> <span class=nx>val</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>digit</span> <span class=o>&lt;=</span> <span class=nx>max</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>radixCountingSort</span><span class=p>(</span><span class=nx>array</span><span class=p>,</span> <span class=nx>digit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 递增位数
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>digit</span> <span class=o>*=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>array</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 计数排序法（递增）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>radixCountingSort</span><span class=p>(</span><span class=nx>array</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>digit</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 一个位数可能的值为-9 ~ +9，共19种可能
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kd>var</span> <span class=nx>counter</span> <span class=p>[</span><span class=mi>19</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>array</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 先计算出目前要看的位数的值之后，再进行-(-9)的索引值位移
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>k</span> <span class=o>:=</span> <span class=p>((</span><span class=nx>n</span> <span class=o>/</span> <span class=nx>digit</span><span class=p>)</span> <span class=o>%</span> <span class=mi>10</span><span class=p>)</span> <span class=o>+</span> <span class=mi>9</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>counter</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>19</span><span class=p>;</span> <span class=nx>i</span> <span class=o>+=</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>counter</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>+=</span> <span class=nx>counter</span><span class=p>[</span><span class=nx>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>length</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>array</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>origin</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nb>copy</span><span class=p>(</span><span class=nx>origin</span><span class=p>,</span> <span class=nx>array</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>-=</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>n</span> <span class=o>:=</span> <span class=nx>origin</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=nx>k</span> <span class=o>:=</span> <span class=p>((</span><span class=nx>n</span> <span class=o>/</span> <span class=nx>digit</span><span class=p>)</span> <span class=o>%</span> <span class=mi>10</span><span class=p>)</span> <span class=o>+</span> <span class=mi>9</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>counter</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span><span class=o>--</span>
</span></span><span class=line><span class=cl>		<span class=nx>array</span><span class=p>[</span><span class=nx>counter</span><span class=p>[</span><span class=nx>k</span><span class=p>]]</span> <span class=p>=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><hr class=post-end><footer class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://lqgl.cool/tags/algorithm>Algorithm</a></span><span class=tag><a href=https://lqgl.cool/tags/go>Go</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>3484 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2022-10-08 02:00</p></footer></article><div class=post-nav><a class=next-post href=https://lqgl.cool/writing/2022/go-interview-summary/><span class=post-nav-label><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>&nbsp;Newer</span><br><span>Go 面试问题汇总</span></a>
<a class=prev-post href=https://lqgl.cool/writing/2022/git-and-operations/><span class=post-nav-label>Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></span><br><span>Git 基本知识与常用指令</span></a></div><button type=button id=scroll-top-btn title=回到顶部><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-up-circle"><circle cx="12" cy="12" r="10"/><polyline points="16 12 12 8 8 12"/><line x1="12" y1="16" x2="12" y2="8"/></svg></button>
<script src=https://giscus.app/client.js data-repo=lqgl/blog data-repo-id="MDEwOlJlcG9zaXRvcnk0MDc1ODU3NjY=" data-category=Announcements data-category-id=DIC_kwDOGEtD5s4CRp8B data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></main><footer id=site-footer class=wrapper><div class=footer-inner><div class=footer-l><nav class=site-nav><a href=https://lqgl.cool>Home</a><span>/</span><a href=../../../writing>Writing</a><span>/</span><a href=../../../gallery>Gallery</a><span>/</span><a href=../../../link>Link</a><span>/</span><a href=../../../about>About</a><span>/</span></nav></div><div class=footer-r><p class=site-copy>&copy; 2023 <a href=https://lqgl.cool>Kami</a> &#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/deed.zh target=_blank rel=noopener>CC BY-NC 4.0</a> &#183; <a href=https://lqgl.cool/writing/index.xml target=_blank title=RSS class=icon-link><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></p></div></div></footer><div class=sakana-box></div><script src=https://cdn.jsdelivr.net/npm/sakana></script>
<script>Sakana.init({el:".sakana-box",character:"chisato",inertia:.01,decay:.99,r:60,y:10,scale:.4,translateY:0,canSwitchCharacter:!1})</script></div><canvas class=fireworks style=position:fixed;left:0;top:0;z-index:1;pointer-events:none></canvas>
<script type=text/javascript src=../../../js/anime.min.js></script>
<script type=text/javascript src=../../../js/firework.js></script><div id=bg-img></div><script src=https://lqgl.cool/js/main.min.07b236541121fc0dbaaa229353e79a5f42e02811b753c6ed2093899c5bac59d2.js integrity="sha256-B7I2VBEh/A26qiKTU+eaX0LgKBG3U8btIJOJnFusWdI="></script>
<script src=../../../js/instant.page-5.1.1.js type=module integrity=sha384-MWfCL6g1OTGsbSwfuMHc8+8J2u71/LA8dzlIN3ycajckxuZZmF+DNjdm7O6H3PSq></script></body></html>