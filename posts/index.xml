<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - Lqgl's Blog</title><link>https://lqgl.cool/posts/</link><description>所有文章 | Lqgl's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>liuguang@duck.com (lqgl)</managingEditor><webMaster>liuguang@duck.com (lqgl)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 08 Oct 2022 10:00:59 +0800</lastBuildDate><atom:link href="https://lqgl.cool/posts/" rel="self" type="application/rss+xml"/><item><title>经典排序算法</title><link>https://lqgl.cool/classic-sorting-algorithms/</link><pubDate>Sat, 08 Oct 2022 10:00:59 +0800</pubDate><author>lqgl</author><guid>https://lqgl.cool/classic-sorting-algorithms/</guid><description>排序算法可以分为内部排序和外部排序。 内部排序是数据记录在内存中进行排序。 而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程</description></item><item><title>Git 基本知识与常用指令</title><link>https://lqgl.cool/git-and-operations/</link><pubDate>Thu, 29 Sep 2022 16:07:11 +0800</pubDate><author>lqgl</author><guid>https://lqgl.cool/git-and-operations/</guid><description>Git代码状态转换图 其中： 未被Git跟踪的状态为unstage状态； 已被Git跟踪的状态为stage状态（stage：阶段），因此包括sta</description></item><item><title>MySQL</title><link>https://lqgl.cool/mysql/</link><pubDate>Thu, 29 Sep 2022 13:59:02 +0800</pubDate><author>lqgl</author><guid>https://lqgl.cool/mysql/</guid><description>MySQL, Oracle，SQL Server 的区别 Oracle 没有自动增长类型，MySQL 和 SQL Server 一般使用自动增长类型 做分页的话，MySQL 使用 Limit，SQL Server 使用 to</description></item><item><title>MySQL 数据库操作</title><link>https://lqgl.cool/mysql-operations/</link><pubDate>Thu, 29 Sep 2022 13:43:16 +0800</pubDate><author>lqgl</author><guid>https://lqgl.cool/mysql-operations/</guid><description>基本查询 1 SELECT * FROM students; 条件查询 1 SELECT * FROM students where score &amp;gt;= 80 AND gender=&amp;#39;M&amp;#39;; score 和 gender 是查询条件 1 SELECT * FROM students WHERE NOT class_id = 2; 按 NOT 条件查询 students，查找条件不为 id=2 的数据 1 SELECT *</description></item><item><title>Docker 安装卸载与镜像容器管理</title><link>https://lqgl.cool/docker-usage/</link><pubDate>Thu, 29 Sep 2022 09:25:18 +0800</pubDate><author>lqgl</author><guid>https://lqgl.cool/docker-usage/</guid><description>Docker 安装与卸载 安装与验证 更新数据源： 1 sudo apt update 安装一些必备软件包，让 apt 通过 HTTPS 使用软件包。 1 sudo apt install apt-transport-https ca-certificates curl software-properties-common 将官方 Docker 版本库的 GPG 密钥添加到系统中： 1 curl</description></item><item><title>When Generics</title><link>https://lqgl.cool/go-when-generics/</link><pubDate>Mon, 19 Sep 2022 09:19:20 +0800</pubDate><author>lqgl</author><guid>https://lqgl.cool/go-when-generics/</guid><description>英文原文：When To Use Generics 介绍 Go 1.18版本增加了一个主要的新语言特性:支持泛型编程。在本文中，我不打算描述泛型是什么，也不打算描述如何使用泛</description></item><item><title>Go Maps</title><link>https://lqgl.cool/go-maps/</link><pubDate>Fri, 16 Sep 2022 14:13:27 +0800</pubDate><author>lqgl</author><guid>https://lqgl.cool/go-maps/</guid><description>英文原文:Go maps in action 介绍 哈希表是计算机科学中最有用的数据结构之一。许多哈希表实现具有不同的属性，但通常它们提供快速查找、添加和删除。Go提供</description></item><item><title>Share Memory By Communicating</title><link>https://lqgl.cool/go-communication/</link><pubDate>Fri, 16 Sep 2022 10:23:46 +0800</pubDate><author>lqgl</author><guid>https://lqgl.cool/go-communication/</guid><description>英文原文: Share Memory By Communicating 传统的线程模型（例如，在编写Java、C++和Python程序时通常使用）要求程序员使用共享内存在线程之间进行通信。 通常情</description></item><item><title>Defer Panic and Recover</title><link>https://lqgl.cool/go-defer-panic-and-recover/</link><pubDate>Fri, 16 Sep 2022 09:49:15 +0800</pubDate><author>lqgl</author><guid>https://lqgl.cool/go-defer-panic-and-recover/</guid><description>英文原文: Defer, Panic, and Recover 介绍 Go有常见的控制流机制：if、for、switch、goto。它也有go语句来运行单独的goroutine中的代码。这</description></item><item><title>Go Slice</title><link>https://lqgl.cool/go-slice/</link><pubDate>Fri, 16 Sep 2022 09:38:33 +0800</pubDate><author>lqgl</author><guid>https://lqgl.cool/go-slice/</guid><description>英文原文:Go Slices: usage and internals 介绍 Go 的切片类型为处理类型化数据的序列提供了一种方便而有效的方法。切片类似于其他语言中的数组，但有一些不寻常的特性。本</description></item></channel></rss>